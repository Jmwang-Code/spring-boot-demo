# 🏗️ G1 垃圾回收器
## 第一阶段：核心架构（底层怎么设计的？）

### 1. Region：化整为零的网格化管理

传统的回收器（如 CMS）将内存划分为连续的、巨大的年轻代和老年代。而 G1 将整个堆拆分成了约 2048(目标值，不是一定是)个 大小相等的独立单元，称为 Region。

- 大小：通常为 1MB（最小确实是 1MB）、2MB、4MB ... 最高可达 32MB（JDK 18+ 支持更大）。
- 逻辑角色：每个 Region 并没有固定的身份。它今天可能是 Eden 区，回收后明天可能变成 Old 区。

堆内存布局示意图

| Eden     | Old      | Survivor | Old      | Eden     |
|----------|----------|----------|----------|----------|
| Old      | Humongous| H-Cont   | Eden     | Survivor |
| Free     | Old      | Eden     | Free     | Old      |
| Survivor | Free     | Humongous| Old      | Free     |

- E (Eden)：年轻代。
- S (Survivor)：幸存区。
- O (Old)：老年代。
- H (Humongous)：巨型对象区。当一个对象超过 Region 大小的 50% 时，它直接进入 H 区。如果一个对象极大，它会占用多个连续的 H 区。

<hr>

### 2. RSet (Remembered Set)：解决跨代引用的“地图”

这是 G1 最精妙也最复杂的底层设计。

痛点：在回收年轻代（Young GC）时，如果老年代的对象引用了年轻代的对象，为了找到这个存活对象，难道要扫描整个老年代吗？那太慢了。

方案：G1 为每一个 Region 都配备了一个 RSet。

记录内容：RSet 记录了“谁引用了我”（Points-into）。

工作机制：当老年代对象 A 引用年轻代对象 B 时，G1 会通过 Write Barrier（写屏障） 技术，在 RSet 中记录下这个引用关系。

有了 RSet 的好处：
在 Young GC 时，我只需要扫描 年轻代 Region + 它们的 RSet 即可。RSet 就像一份精确的索引，告诉 G1：“老年代里有哪几个位置引用了我们，直接去那看就行，别扫描全场”。

<hr>

### 3. CSet (Collection Set)：待收割的“清单”

CSet 是本次 GC 准备回收的 Region 集合。

Young GC 时：CSet 只包含所有的年轻代 Region。

Mixed GC 时：CSet 包含所有的年轻代 Region + 部分收益最高的老年代 Region。

G1 会根据你设定的 -XX:MaxGCPauseMillis（预期停顿时间），计算出在限定时间内能清理多少个 Region，然后把最值得清理（垃圾最多）的 Region 放入 CSet。


由于 G1有很多结构是用来管理的，所以小内存的服务并不适合，因为他的`Region的内部元数据`、`RSet`就会占用100MB-300MB

1. Region 分区模型：为什么不再需要“连续”的空间？好比打扫一个大礼堂，你必须一次性扫完，非常耗时，Region划分了区域，现在只需要清扫需要清理的区域即可。

2. RSet (Remembered Set)：G1 解决跨代引用（关键！面试必考）的核心机制？制作一个引用字典，可以快速寻找老年代有没有引用年轻代的对象。

3. CSet (Collection Set)：回收的目标清单?Young GC回收CSet中所有的年轻代Region。Mixed GC回收CSet中所有年轻代 Region + 部分老年代 Region。核心算法：挑选出性价比最高的 Region 放入 CSet。

## 第二阶段：运作过程（它是如何工作的？）
Young GC 流程：STW（Stop-The-World）期间发生了什么。

并发标记周期 (Concurrent Marking)：

SATB (Snapshot-At-The-Beginning)：如何保证在不停程序的情况下标记对象。

三色标记算法：理解漏标、错标的底层逻辑。

Mixed GC (混合回收)：G1 真正强大的地方，如何动态平衡回收收益。

Full GC 的退化：什么情况下 G1 会退化成单线程收缩？（这是调优要避免的噩梦）。

## 第三阶段：核心算法与特性（为什么快？）
Pause Prediction Model：基于衰减均值（Decaying Average）的停顿时间预测模型。

Copying 算法：为什么 G1 几乎没有碎片化问题。

TAMS (Top-at-Mark-Start)：并发标记期间的内存分配指针。

## 第四阶段：实战调优（线上怎么排查？）
关键参数详解：不仅仅是 -Xmx，还有 MaxGCPauseMillis 的艺术。

日志深度解析：学会阅读 Java 11/17 的 -Xlog:gc* 统一日志格式。

常见场景调优：

解决 Evacuation Failure (转移失败)。

处理 Humongous Allocation 导致的频繁 GC。

平衡吞吐量与低延迟的“甜点区”。

## 第五阶段：横向对比（知己知彼）
G1 vs CMS：为什么 JDK 9 要弃用 CMS？

G1 vs ZGC：在 2026 年，什么场景该从 G1 升级到 ZGC？

