# 1. Mysql中的锁
基于锁的属性分类：共享锁（读锁）和排他锁（写锁）
基于锁的粒度分类：表锁、行锁、页锁、记录锁、间隙锁、临键锁
基于锁的状态分类：意向共享锁、意向排他锁
基于锁的算法分类：乐观锁、悲观锁

## 1.1 共享锁（读锁）
共享锁又称为读锁，当一个事务为数据加上读锁，其他事务不可以加写锁，但可以加读锁。读锁可以共享，多个事务可以同时对一份数据加读锁，互不阻塞。

## 1.2 排他锁（写锁）
排他锁又称为写锁，当一个事务为数据加上写锁，其他事务不可以加读锁和写锁。写锁是独占的，只有一个事务可以对数据加上写锁，其他事务必须等待该事务释放写锁后才能再次加锁。

## 1.3 意向共享锁
意向共享锁是表级锁，当一个事务为数据加上共享锁时，事务会先尝试加意向共享锁，如果加锁成功，再尝试加共享锁，如果加锁失败，事务会回滚。

## 1.4 意向排他锁
意向排他锁是表级锁，当一个事务为数据加上排他锁时，事务会先尝试加意向排他锁，如果加锁成功，再尝试加排他锁，如果加锁失败，事务会回滚。

## 1.5 乐观锁
乐观锁是一种乐观的加锁策略，它乐观的认为事务之间不会发生冲突，所以不加锁。当事务提交时，会检查事务期间是否修改过数据，如果修改过，事务提交失败。（可以通过CAS和版本号机制实现）

## 1.6 悲观锁
悲观锁是一种悲观的加锁策略，它悲观的认为事务之间会发生冲突，所以提前加锁。当事务提交时，会检查事务期间是否修改过数据，如果修改过，事务提交失败。

## 1.7 表锁
对整张表加锁，实现简单，资源消耗小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。

## 1.8 页锁
对表中的一个页加锁，锁定粒度介于表锁和行锁之间，发生锁冲突的概率介于表锁和行锁之间，并发度介于表锁和行锁之间，但是加锁消耗资源介于表锁和行锁之间，加锁速度介于表锁和行锁之间，会出现死锁。

## 1.9 行锁
对表中的一行数据加锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高，但是加锁消耗资源大，加锁慢，会出现死锁。

## 1.10 记录锁
对表中的一条记录加锁，是行锁的一种特例。

## 1.11 间隙锁
对一个范围加锁，但不包含记录本身，是行锁的一种特例。

## 1.12 临键锁
对一个范围加锁，包含记录本身，是行锁的一种特例。
