# 1. Mysql中的锁
基于锁的属性分类：共享锁（读锁）和排他锁（写锁）
基于锁的粒度分类：表锁、行锁、页锁、记录锁、间隙锁、临键锁
基于锁的状态分类：意向共享锁、意向排他锁
基于锁的算法分类：乐观锁、悲观锁

## 1.1 共享锁（读锁）
共享锁又称为读锁，当一个事务为数据加上读锁，其他事务不可以加写锁，但可以加读锁。读锁可以共享，多个事务可以同时对一份数据加读锁，互不阻塞。

## 1.2 排他锁（写锁）
排他锁又称为写锁，当一个事务为数据加上写锁，其他事务不可以加读锁和写锁。写锁是独占的，只有一个事务可以对数据加上写锁，其他事务必须等待该事务释放写锁后才能再次加锁。

## 1.3 意向共享锁
意向共享锁是表级锁，当一个事务为数据加上共享锁时，事务会先尝试加意向共享锁，如果加锁成功，再尝试加共享锁，如果加锁失败，事务会回滚。

## 1.4 意向排他锁
意向排他锁是表级锁，当一个事务为数据加上排他锁时，事务会先尝试加意向排他锁，如果加锁成功，再尝试加排他锁，如果加锁失败，事务会回滚。

## 1.5 乐观锁
乐观锁是一种乐观的加锁策略，它乐观的认为事务之间不会发生冲突，所以不加锁。当事务提交时，会检查事务期间是否修改过数据，如果修改过，事务提交失败。（可以通过CAS和版本号机制实现）

## 1.6 悲观锁
悲观锁是一种悲观的加锁策略，它悲观的认为事务之间会发生冲突，所以提前加锁。当事务提交时，会检查事务期间是否修改过数据，如果修改过，事务提交失败。

## 1.7 表锁
对整张表加锁，实现简单，资源消耗小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。

## 1.8 页锁
对表中的一个页加锁，锁定粒度介于表锁和行锁之间，发生锁冲突的概率介于表锁和行锁之间，并发度介于表锁和行锁之间，但是加锁消耗资源介于表锁和行锁之间，加锁速度介于表锁和行锁之间，会出现死锁。

## 1.9 行锁
对表中的一行数据加锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高，但是加锁消耗资源大，加锁慢，会出现死锁。

## 1.10 记录锁
对表中的一条记录加锁，是行锁的一种特例。

## 1.11 间隙锁
对一个范围加锁，但不包含记录本身，是行锁的一种特例。

## 1.12 临键锁
对一个范围加锁，包含记录本身，是行锁的一种特例。

# 2. 事务的四大特性（ACID）
## 2.1 原子性（Atomicity）
事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。

## 2.2 一致性（Consistency）
事务执行前后，数据保持一致。

## 2.3 隔离性（Isolation）
多个事务并发执行时，事务之间是相互隔离的，一个事务不应该影响其他事务。

## 2.4 持久性（Durability）
事务执行成功后，对数据的修改是永久的。

# 3. 事务的隔离级别
## 3.1 未提交读（Read Uncommitted）
事务可以读取未提交的数据，会出现脏读、不可重复读、幻读。

## 3.2 提交读（Read Committed）
事务只能读取已提交的数据，会出现不可重复读、幻读。

## 3.3 可重复读（Repeatable Read）
事务可以多次读取同一数据，不会出现脏读、不可重复读，会出现幻读。

## 3.4 串行化（Serializable）
事务串行执行，不会出现脏读、不可重复读、幻读。

# 4. 事务隔离级别的问题
## 4.1 脏读
事务A读取了事务B未提交的数据，事务B回滚，事务A读取到了脏数据。

## 4.2 不可重复读
事务A多次读取同一数据，事务B修改了数据并提交，事务A多次读取的数据不一致。

## 4.3 幻读
事务A多次读取同一数据，事务B插入了数据并提交，事务A多次读取的数据不一致。

# 5. 数据库不使用二叉树、红黑树、B树、Hash表？ 而是使用了B+树
## 5.1 二叉树
在最坏的情况下会退化为链表形态，变成了顺序查找，遍历整个链。
![img.png](img.png)

## 5.1 红黑树

![img_1.png](img_1.png)