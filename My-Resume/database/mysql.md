# 1. Mysql中的锁
基于锁的属性分类：共享锁（读锁）和排他锁（写锁）
基于锁的粒度分类：表锁、行锁、页锁、记录锁、间隙锁、临键锁
基于锁的状态分类：意向共享锁、意向排他锁
基于锁的算法分类：乐观锁、悲观锁

## 1.1 共享锁（读锁）
共享锁又称为读锁，当一个事务为数据加上读锁，其他事务不可以加写锁，但可以加读锁。读锁可以共享，多个事务可以同时对一份数据加读锁，互不阻塞。

## 1.2 排他锁（写锁）
排他锁又称为写锁，当一个事务为数据加上写锁，其他事务不可以加读锁和写锁。写锁是独占的，只有一个事务可以对数据加上写锁，其他事务必须等待该事务释放写锁后才能再次加锁。

## 1.3 意向共享锁
意向共享锁是表级锁，当一个事务为数据加上共享锁时，事务会先尝试加意向共享锁，如果加锁成功，再尝试加共享锁，如果加锁失败，事务会回滚。

## 1.4 意向排他锁
意向排他锁是表级锁，当一个事务为数据加上排他锁时，事务会先尝试加意向排他锁，如果加锁成功，再尝试加排他锁，如果加锁失败，事务会回滚。

## 1.5 乐观锁
乐观锁是一种乐观的加锁策略，它乐观的认为事务之间不会发生冲突，所以不加锁。当事务提交时，会检查事务期间是否修改过数据，如果修改过，事务提交失败。（可以通过CAS和版本号机制实现）

## 1.6 悲观锁
悲观锁是一种悲观的加锁策略，它悲观的认为事务之间会发生冲突，所以提前加锁。当事务提交时，会检查事务期间是否修改过数据，如果修改过，事务提交失败。

## 1.7 表锁
对整张表加锁，实现简单，资源消耗小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。

## 1.8 页锁
对表中的一个页加锁，锁定粒度介于表锁和行锁之间，发生锁冲突的概率介于表锁和行锁之间，并发度介于表锁和行锁之间，但是加锁消耗资源介于表锁和行锁之间，加锁速度介于表锁和行锁之间，会出现死锁。

## 1.9 行锁
对表中的一行数据加锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高，但是加锁消耗资源大，加锁慢，会出现死锁。

## 1.10 记录锁
对表中的一条记录加锁，是行锁的一种特例。

## 1.11 间隙锁
对一个范围加锁，但不包含记录本身，是行锁的一种特例。

## 1.12 临键锁
对一个范围加锁，包含记录本身，是行锁的一种特例。

# 2. 事务的四大特性（ACID）
## 2.1 原子性（Atomicity）
事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。

## 2.2 一致性（Consistency）
事务执行前后，数据保持一致。

## 2.3 隔离性（Isolation）
多个事务并发执行时，事务之间是相互隔离的，一个事务不应该影响其他事务。

## 2.4 持久性（Durability）
事务执行成功后，对数据的修改是永久的。

# 3. 事务的隔离级别
## 3.1 未提交读（Read Uncommitted）
事务可以读取未提交的数据，会出现脏读、不可重复读、幻读。

## 3.2 提交读（Read Committed）
事务只能读取已提交的数据，会出现不可重复读、幻读。

## 3.3 可重复读（Repeatable Read）
事务可以多次读取同一数据，不会出现脏读、不可重复读，会出现幻读。

## 3.4 串行化（Serializable）
事务串行执行，不会出现脏读、不可重复读、幻读。

# 4. 事务隔离级别的问题
## 4.1 脏读
事务A读取了事务B未提交的数据，事务B回滚，事务A读取到了脏数据。

## 4.2 不可重复读
事务A多次读取同一数据，事务B修改了数据并提交，事务A多次读取的数据不一致。

## 4.3 幻读
事务A多次读取同一数据，事务B插入了数据并提交，事务A多次读取的数据不一致。

# 5. 数据库不使用二叉树、红黑树、B树、Hash表？ 而是使用了B+树
## 5.1 二叉树
在最坏的情况下会退化为链表形态，变成了顺序查找，遍历整个链。
![img.png](img.png)

## 5.1 红黑树
红黑树但是一种特殊的平衡二叉树，属于二叉树，一个父节点只能跟着2个子节点。如果存在几千万数据，那么红黑树会非常的深同样需要大量io操作。
![img_1.png](img_1.png)

## 5.2 B树
B层数过深导致查询效率低下，每个节点空间过小，所以增大节点空间，将每个叶子节点都存放多个索引元素和对应的多个data。
有效的控制了层数，这样矮胖的树结构，减少了io操作
![img_2.png](img_2.png)

## 5.3 B+树
B树还有一个问题，由于非叶子节点也存放了data数据,占用了大量的空间。B+树中将非叶子节点中的data数据删除，而是单纯的放置冗余索引和对应的节点地址，使得一个非叶子节点可以存放更多的冗余索引，查找时，对当前非叶子节点使用二分折半查找。
并且叶子节点中使用指针相连，提高了区间访问性能，支持范围查找。每一层都是有序存储的。
![img_3.png](img_3.png)

## 5.4 为什么使用B+树
- 叶子节点有序查询，支持范围查找
- 所有的查询都是查找到叶子节点，查询稳定
- 非叶子节点可以存储更多的索引元素+地址，使得IO操作减少

3层B+树可以存储百万级别的数据，而且查询效率非常高。

# 6. B+树的优点
1. 非叶子节点可以存储跟多的索引元素+地址，使得IO操作减少。
2. 所有查找的都是查找到最底层的叶子节点，查找性能稳定。
3. 并且叶子节点是有序链表，方便范围查找。

# 7. 数据库为什么不使用Hash表
hash表虽然是O(1)的查询效率，但是大量的数据会有大量的hash冲突，查询效率也会从O（1）退化到O（n）。（虽然即使千万数据 hash表还是效率高于B+tree）
主要原因：hash表没有排序，不支持范围查找。