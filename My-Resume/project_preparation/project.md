# 项目准备

# 1. 实体识别树
| \                                   | <span style="color:purple">HDFS                                                      | 
|-------------------------------------|--------------------------------------------------------------------------------------|
| <span style="color:red">**组件理论**  | 缓存机制 日志先行机制 数据源内核（这个可以优化自动加载还是手动都是加锁在查询器上，如果让锁粒度细化到每个节点上，并行效率就大大提高了） 荷官（哨兵机制） 备用主从机制 |
| <span style="color:red">**问题定位**  | 1.实体识别树补全实体识别树之外的空缺 2.希望减少在结构化中的耗时，将耗时功能都简化 3.树之间的数据一致性 4.数据恢复问题                     |
| <span style="color:red">**调优配置**  | 使用G1解决大内存FULL GC的问题                                                                  |
| <span style="color:red">**基础理论**  | 字典树、前缀树核心算法                                                                          |
| <span style="color:red">**项目场景**  |                                                                                      |
| <span style="color:red">**特色问题1** |                                                                                      |
| <span style="color:red">**特色问题2** |                                                                                      |

G1 :java -XX:+UseG1GC -Xmx40g -XX:ConcGCThreads=8 -XX:G1HeapRegionSize=32m -XX:MaxGCPauseMillis=200 -XX:G1NewSizePercent=40
垃圾回收时间控制在200ms左右，内存分配率控制在 40% 左右，

**G1 垃圾回收器相对于 JDK8 默认垃圾回收器（Parallel GC）的好处主要有以下几点：**
- 高效：G1 垃圾回收器是一种面向大堆的垃圾回收器，可以有效地处理大型内存和多核处理器的情况，具有高效、低延迟、可预测的特点。
- 低延迟：G1 垃圾回收器采用分代回收和并发标记-整理算法，可以在不影响应用程序运行的情况下进行垃圾回收，从而实现低延迟的垃圾回收。
- 可预测：G1 垃圾回收器可以根据实际情况动态调整垃圾回收策略和参数，从而实现可预测的垃圾回收。
- 避免全局停顿：G1 垃圾回收器可以将堆内存分成多个区域，每个区域独立进行垃圾回收，从而避免全局停顿的情况。
- 避免内存碎片：G1 垃圾回收器采用分代回收和并发标记-整理算法，可以避免内存碎片的情况，从而提高了内存利用率和性能。

# 2. 数据报表


# 3. 中台数据调度

